"use strict";

var BUILD_VERSION = "0.0.11";

var parseSelector = (parseAttrSelector = require('./parseSelector.js')).parseSelector, parseAttrSelector = parseAttrSelector.parseAttrSelector;
var matchAttributes = (require('./matchSelector.js')).matchAttributes;
var TokenList = require('./TokenList.js');

var assert = function(expect, msg) {
	if( expect != true ) {
		throw new Error(msg || "");
	}
};

var ASTQuery = (function(){function ITER$0(v,f){if(v){if(Array.isArray(v))return f?v.slice():v;var i,r;if(typeof v==='object'&&typeof v['@@iterator']==='function'){i=v['@@iterator'](),r=[];while((f=i['next']()),f['done']!==true)r.push(f['value']);return r;}}throw new Error(v+' is not iterable')};function GET_ITER$0(v){if(v){if(Array.isArray(v))return 0;if(typeof v==='object'&&typeof v['@@iterator']==='function')return v['@@iterator']();}throw new Error(v+' is not iterable')};
	ASTQuery.getVisitorKeys = function(visitorKeysName) {
		if ( typeof visitorKeysName === 'object' ) {
			return visitorKeysName;
		}
		else {
			visitorKeysName = String(visitorKeysName).toLowerCase();
			try {
				return require((("./keys/" + visitorKeysName) + ".js"));
			}
			catch(e) {
				throw new Error((("Unrecognized type of visitor keys \"" + visitorKeysName) + "\""));
			}
		}
	}

	function ASTQuery(ast, visitorKeys) {var options = arguments[2];if(options === void 0)options = {};
		this.visitorKeys = ASTQuery.getVisitorKeys(visitorKeys);

		this.ast = ast;

		this.options = options;
		if ( this.options.attrNameAsPath === void 0 ) {
			this.options.attrNameAsPath = true;
		}

		this._sourceIndex = 0;
		this._prevNode = void 0;

		this.reset();
	}Object.defineProperties(ASTQuery.prototype, {callbacksCollected: {"get": callbacksCollected$get$0, "set": callbacksCollected$set$0, "configurable": true, "enumerable": true}});

	ASTQuery.prototype.reset = function() {
		this.mods = new TokenList;

		this._selectorGroup = 0;
		this._typeSelectorsMap = Object.create(null);
		this._typeSelectorsMap["*"] = [];
		this._nameSelectorsMap = Object.create(null);
//		this._classSelectorsMap = Object.create(null);
		this._preudoSelectorsMap = Object.create(null);

		this.callbacksCollected = false;
		this.currentNode = void 0;
	}

	function callbacksCollected$get$0() {
		return this._callbacksCollected;
	}

	function callbacksCollected$set$0(val) {
		if ( val === false ) {
			this._matchedCallbacks = void 0;
		}
		this._callbacksCollected = val;
		return val;
	}

	ASTQuery.prototype._prepareNode = function(node, parentNode, parentProp, childIndex) {
		var prevNode = this._prevNode;

		node["$sourceIndex"] = this._sourceIndex++;

		if( parentNode ) {
			node["$parentNode"] = parentNode;
			node["$parentProp"] = parentProp;

			if( childIndex !== void 0 ) {
				node["$childIndex"] = childIndex;
			}

			(parentNode["$children"] || (parentNode["$children"] = [])).push(node);
		}

		if ( prevNode )prevNode["$nextElementSibling"] = node;
		node["$previousElementSibling"] = prevNode;
		this._prevNode = node;
	}

	ASTQuery.prototype._isInMods = function(defaultMod) {var SLICE$0 = Array.prototype.slice;var mods = SLICE$0.call(arguments, 1);var this$0 = this;
		if ( !mods.length && !this.mods.length ) {
			return true;
		}

		return mods.every( function(mod)  {
			if ( mod == '*' ) {
				return true;
			}

			if ( defaultMod ) {
				if ( Array.isArray(defaultMod) ) {
					if ( defaultMod.indexOf(mod) !== -1 ) {
						return true;
					}
				}
				else if ( ("" + defaultMod) === ("" + mod) ) {
					return true;
				}
			}

			return this$0.mods.contains(mod);
		} );
	}

	ASTQuery.prototype._getSelectorMods = function(selector) {
		selector = selector.trim();

		var isPost = selector[0] === '^';
		if ( isPost ) {
			selector = selector.substr(1).trim();//TODO:: trimLeft()
		}

		var mods = selector[0] === '?';
		if ( mods ) {
			var index = selector.indexOf(" ");
			var isUniversal = false;

			mods =
				selector.substr(1, index).split("?")
					.map( function(ns)  {
						ns = ns.trim();
						if ( ns == "" || ns == "*" ) {
							isUniversal = true;
						}
						return ns;
					} )
			;
			if ( isUniversal ) {
				mods = ["*"];
			}

			selector = selector.substr(index).trim();//TODO:: trimLeft()
		}
		else {
			mods = void 0;
		}

		return {
			selector: selector
			, isPost: isPost
			, mods: mods
		}
	}

	ASTQuery.prototype.addListener = function(sel, callback) {var $D$1;var $D$2;var $D$3;var $D$4;var group = ((group = (self = (arguments[2] !== void 0 ? arguments[2] : {})).group) === void 0 ? this._selectorGroup : group), mod = self.mod, defaultMod = self.defaultMod, self = self.self;
		assert(typeof callback === 'function', 'Callback must be a function');

		group = group | 0;

		var typeSelectorsMap = this._typeSelectorsMap
			, nameSelectorsMap = this._nameSelectorsMap
//			, preudoSelectorsMap = this._preudoSelectorsMap
		;

		var selector = (mods = this._getSelectorMods(("" + sel))).selector, isPost = mods.isPost, mods = mods.mods;
		if ( isPost ) {
			this._isPostCallbacks = true;
		}

		var typeName, nameValue, className, attrRules, pseudoClass, isParentSelector, nextRule;$D$4 = (parseSelector(selector));$D$1 = GET_ITER$0($D$4);$D$2 = $D$1 === 0;$D$3 = ($D$2 ? $D$4.length : void 0);for (  ; $D$2 ? ($D$1 < $D$3) : !($D$3 = $D$1["next"]())["done"]; ){;typeName = (nextRule = ($D$2 ? $D$4[$D$1++] : $D$3["value"]))[2], nameValue = nextRule[3], className = nextRule[4], attrRules = ((attrRules = nextRule[5]) === void 0 ? [] : attrRules), pseudoClass = nextRule[6], isParentSelector = nextRule[7], nextRule = nextRule[9];

			if ( nextRule ) {
				throw new Error("Complex selectors doesn't supported for now");
			}

			if ( className || pseudoClass || isParentSelector ) {
				throw new Error((("Not supported for now \"" + (className || pseudoClass || (isParentSelector ? "!" : ""))) + "\""));
			}

			var callbacks = void 0;

			if( nameValue ) {
				if ( typeName ) {
					attrRules.push(parseAttrSelector((("[type=" + typeName) + "]"))[0]);
				}

				callbacks = nameSelectorsMap[nameValue];
				if ( !callbacks ) {
					callbacks = nameSelectorsMap[nameValue] = [];
				}
			}
			else if( typeName ) {
				if ( nameValue ) {
					attrRules.push(parseAttrSelector((("[name=" + nameValue) + "]"))[0]);
				}

				callbacks = typeSelectorsMap[typeName];
				if ( !callbacks ) {
					callbacks = typeSelectorsMap[typeName] = [];
				}
			}
			else {
				callbacks = typeSelectorsMap["*"];
			}

			callbacks.push({callback: callback, attrRules: attrRules, isPost: isPost, group: group, mods: mods, defaultMod: defaultMod, self: self});
		};$D$1 = $D$2 = $D$3 = $D$4 = void 0;
	}

	ASTQuery.prototype.on = function(selectorsMap) {var prefix = (group = (arguments[1] !== void 0 ? arguments[1] : {})).prefix, mod = group.mod, defaultMod = group.defaultMod, group = ((group = group.group) === void 0 ? this._selectorGroup++ : group);
		assert(typeof selectorsMap === 'object');

		var prefixLength = 0;
		if ( prefix !== void 0 ) {
			prefix = String(prefix);
			prefixLength = prefix.length;
		}

		for ( var selector in selectorsMap ) if ( selectorsMap.hasOwnProperty(selector) ) {
			var callback = selectorsMap[selector];

			if ( prefix ) {
				if ( selector.substring(0, prefixLength) !== prefix ) {
					continue;
				}
				selector = selector.substring(prefixLength);
			}

			this.addListener(selector, callback, {mod: mod, defaultMod: defaultMod, group: group, self: selectorsMap})
		}
	}

	ASTQuery.prototype.findAll = function(root, selector, onlyFirst) {
		// TODO::
	}

	ASTQuery.prototype.find = function(root, selector) {
		return this.findAll(root, selector, true)[0];
	}

	ASTQuery.prototype.match = function(node, selector, scope) {
		// TODO::
	}

	ASTQuery.prototype.traverse = function(node, pre, post) {var this$0 = this;
		var onpreparenode = (this.options).onpreparenode;
		if ( typeof onpreparenode !== 'function' ) {
			onpreparenode = void 0;
		}

		if ( node === void 0 ) {
			if ( typeof pre === 'function' ) {
				post = pre;
				node = this.ast;
				pre = void 0;
			}
		}

		if ( pre === void 0 ) {
			if ( typeof node === 'function' ) {//astQuery.traverse(function(anyNode){})
				pre = node;
				node = this.ast;
			}
			else if ( typeof post === 'function' ) {
				pre = function()  {};
			}
		}
		if ( typeof post !== 'function' ) {
			post = void 0;
		}

		var prepared = this._prepared;

		var visit = function(node, parentNode, parentProp, childIndex)  {var $D$5;var $D$6;var $D$7;var $D$8;var $D$9;var $D$10;var $D$11;
			if ( !prepared ) {
				this$0._prepareNode(node, parentNode, parentProp, childIndex);

				if ( onpreparenode ) {
					onpreparenode(node, parentNode, parentProp, childIndex);
				}
			}

			var goDeeper = pre(node, parentNode, parentProp, childIndex, false);

			if ( goDeeper !== false ) {
				$D$8 = (this$0.visitorKeys[node.type] || []);$D$5 = GET_ITER$0($D$8);$D$6 = $D$5 === 0;$D$7 = ($D$6 ? $D$8.length : void 0);for ( var propName ; $D$6 ? ($D$5 < $D$7) : !($D$7 = $D$5["next"]())["done"]; ){propName = ($D$6 ? $D$8[$D$5++] : $D$7["value"]);
					var child = node[propName];

					if ( Array.isArray(child) ) {
						var childIndex$0 = 0;
						$D$9 = GET_ITER$0(child);$D$10 = $D$9 === 0;$D$11 = ($D$10 ? child.length : void 0);for ( var _child = void 0 ; $D$10 ? ($D$9 < $D$11) : !($D$11 = $D$9["next"]())["done"]; ){_child = ($D$10 ? child[$D$9++] : $D$11["value"]);if ( _child ) {
							if ( visit(_child, node, propName, childIndex$0++) === false ) {
								return false;
							}
						}};$D$9 = $D$10 = $D$11 = void 0;
					}
					else if ( child ) {
						if ( visit(child, node, propName) === false ) {
							return false;
						}
					}
				};$D$5 = $D$6 = $D$7 = $D$8 = void 0;
			}

			if ( post ) {
				post(node, parentNode, parentProp, childIndex, true);
			}
		};

		if ( !prepared ) {
			this._sourceIndex = 0;
			this._prevNode = void 0;
			this._prepared = true;
		}

		visit(node);
	}

	ASTQuery.prototype._collectCallbacks = function() {var this$0 = this;
		if ( this.callbacksCollected ) {
			return;
		}

		var typeSelectorsMap = this._typeSelectorsMap
			, nameSelectorsMap = this._nameSelectorsMap
//			, preudoSelectorsMap = this._preudoSelectorsMap
			, matchedCallbacks = this._matchedCallbacks = []
			, onnode = (this.options).onnode
			, universalSelectorsMap = typeSelectorsMap["*"]
		;

		var isPostCallbacks = this._isPostCallbacks;

		if ( typeof onnode !== 'function' ) {
			onnode = void 0;
		}

		var callback = function(node, parentNode, parentProp, childIndex, isPostCallback)  {var $D$12;var $D$13;var $D$14;
			if ( onnode && !isPostCallback ) {
				if ( onnode(node, parentNode, parentProp, childIndex) === false ) {
					return false;
				}
			}

			var selectorsMap = [].concat(ITER$0(universalSelectorsMap, true), ITER$0(typeSelectorsMap[node.type] || nameSelectorsMap[node.name] || []));

			var callback, attrRules, isPost, mods, group, self;$D$12 = GET_ITER$0(selectorsMap);$D$13 = $D$12 === 0;$D$14 = ($D$13 ? selectorsMap.length : void 0);for (  ; $D$13 ? ($D$12 < $D$14) : !($D$14 = $D$12["next"]())["done"]; ){;callback = (self = ($D$13 ? selectorsMap[$D$12++] : $D$14["value"])).callback, attrRules = self.attrRules, isPost = ((isPost = self.isPost) === void 0 ? false : isPost), mods = self.mods, group = self.group, self = self.self;
				if( isPost == isPostCallback
					&& (!attrRules || !attrRules.length || matchAttributes(node, attrRules, this$0.options))
				) {
					var matchedCallbacksGroup = matchedCallbacks[group];
					if ( !matchedCallbacksGroup ) {
						matchedCallbacksGroup = matchedCallbacks[group] = [];
					}
					matchedCallbacksGroup.push({callback: callback, node: node, mods: mods, self: self});
				}
			};$D$12 = $D$13 = $D$14 = void 0;
		};

		this.traverse(this.ast, callback, isPostCallbacks ? callback : void 0);
	}

	ASTQuery.prototype.apply = function() {var $D$0;var $D$15;var $D$16;var $D$17;var $D$18;var $D$19;var $D$20;var $D$21;var mod = (group = (arguments[0] !== void 0 ? arguments[0] : {})).mod, group = group.group;//TODO:: apply({group: index}) tests
		if ( group !== void 0 ) {
			group = +group;
			if ( isNaN(group) ) {
				group = void 0;
			}
		}

		if ( mod !== void 0 ) {
			if ( Array.isArray(mod) ) {
				($D$0 = this.mods).add.apply($D$0, ITER$0(mod));
			}
			else {
				this.mods.add(mod);
			}
		}

		{
			this._collectCallbacks();
			var matchedCallbacks = this._matchedCallbacks;

			if ( group !== void 0 ) {
				matchedCallbacks = [ matchedCallbacks[group] ];
			}

			$D$15 = GET_ITER$0(matchedCallbacks);$D$16 = $D$15 === 0;$D$17 = ($D$16 ? matchedCallbacks.length : void 0);for ( var matchedCallbacksGroup ; $D$16 ? ($D$15 < $D$17) : !($D$17 = $D$15["next"]())["done"]; ){matchedCallbacksGroup = ($D$16 ? matchedCallbacks[$D$15++] : $D$17["value"]);
				var callback, node, mods, defaultMod, self;$D$21 = (matchedCallbacksGroup || []);$D$18 = GET_ITER$0($D$21);$D$19 = $D$18 === 0;$D$20 = ($D$19 ? $D$21.length : void 0);for (  ; $D$19 ? ($D$18 < $D$20) : !($D$20 = $D$18["next"]())["done"]; ){;callback = (self = ($D$19 ? $D$21[$D$18++] : $D$20["value"])).callback, node = self.node, mods = self.mods, defaultMod = self.defaultMod, self = ((self = self.self) === void 0 ? null : self);
					if ( !mods && !this.mods.length || mods && this._isInMods.apply(this, [defaultMod].concat(ITER$0(mods))) ) {
						this.currentNode = node;
						callback.call(self, node, this);
						this.currentNode = void 0;
					}
				};$D$18 = $D$19 = $D$20 = $D$21 = void 0;
			};$D$15 = $D$16 = $D$17 = void 0;
		}

		if ( mod !== void 0 ) {
			if ( Array.isArray(mod) ) {
				($D$0 = this.mods).remove.apply($D$0, ITER$0(mod));
			;$D$0 = void 0}
			else {
				this.mods.remove(mod);
			}
		}
	}

	ASTQuery.prototype.getAST = function(cleanup) {var cleanup = cleanup.cleanup;var this$0 = this;//TODO:: tests
		var ast = this.ast;

		if ( cleanup === true ) {
			this._prepared = false;
			this.callbacksCollected = false;
			var visitorKeysMaps = {};

			this.traverse(ast, function(node)  {
				var visitorKeysMap = visitorKeysMaps[node.type];
				if ( !visitorKeysMap ) {
					visitorKeysMap = visitorKeysMaps[node.type] = this$0.visitorKeys[node.type].reduce(
						function(val, name)  {
							val[name] = null;
							return val;
						}, {}
					);
				}

				for( var propName in node ) if ( node.hasOwnProperty(propName) ) {
					if ( visitorKeysMap[propName] === void 0 ) {
						delete node[propName];
					}
				}
			});
		}

		return ast;
	}
;return ASTQuery;})();
ASTQuery.version = BUILD_VERSION;

module["exports"] = ASTQuery;
